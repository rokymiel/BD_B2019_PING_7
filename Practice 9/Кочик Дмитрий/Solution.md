### Задача 1.
## а)
Т.к. дерево хранится в памяти, будем считать, что на поиск подходящего листа дерева мы не тратим время.  
Каждый лист ссылается на 1 запись => последовательный доступ мы не будем использовать.  
=> чтобы прочитать n записей нам потребуется потратить n * 28 миллисекунд.  
## б)
1. Для полного сканирования таблицы мы потратим 28 * (число страниц) + 0.28 * (оставшееся число записей) = 280.000.000 + 0.28 * 99.000.000 = 15,4(7) часов.  
Для чтения n записей из дерева нам потребуется n * 28 миллисекунд => Нам выгоднее использовать индекс пока n < 55 720 000 / 28 = 1.990.000 т.е.
пока нам нужно прочитать меньше 1.99% записей.
2. Используя полное сканирование мы потратим 55.720.000 миллисекунд, используя дерево - 100.000.000 * 28 = 2.800.000.000 миллисекунд => на ~ 762,3 часа больше.
### Задача 2.
Пусть A - размер первой таблицы, B - второй, тогда:
* Nested-loop Join - всегда A + B
* (Grace) Hash Join - всегда min(A, B)
* Sort Merge Join - 
* Table Scan
* Index Scan
### Задача 3.
### Задача 4.
